import platform
from unittest.mock import Mock
from pathlib import Path

import pytest

from ploomber import DAG
from ploomber.tasks import PythonCallable, SQLScript
from ploomber.products import (File, SQLRelation, SQLiteRelation,
                               GenericSQLRelation, PostgresRelation)
from ploomber.exceptions import DAGWithDuplicatedProducts
from ploomber.dag import util


def dag_simple():
    dag = DAG()

    PythonCallable(touch_root, File('output/first'), dag, name='task')
    PythonCallable(touch_root, {
        'product': File('output/product'),
        'another': File('output/another')
    },
                   dag,
                   name='another')

    return dag


def dag_another():
    dag = DAG()

    PythonCallable(touch_root, File('products/first'), dag, name='task')
    PythonCallable(touch_root, {
        'product': File('output/something/product'),
        'another': File('output/another')
    },
                   dag,
                   name='another')

    return dag


def touch_root(product):
    Path(str(product)).touch()


def touch(upstream, product):
    Path(str(product)).touch()


def test_duplicated_files():
    dag = DAG()
    PythonCallable(touch_root, File('a'), dag, name='task')
    PythonCallable(touch_root, File('a'), dag, name='another')

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    expected = ("Tasks must generate unique products. The following "
                "products appear in more than one task:\n* File('a') "
                "generated by tasks: 'another', and 'task'")

    assert expected == str(excinfo.value)


def test_duplicated_files_one_absolute():
    dag = DAG()
    PythonCallable(touch_root, File('a'), dag, name='task')
    PythonCallable(touch_root, File(Path('a').resolve()), dag, name='another')

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    expected = ("Tasks must generate unique products. The following "
                "products appear in more than one task:\n* File('a') "
                "generated by tasks: 'another', and 'task'")

    assert expected == str(excinfo.value)


def test_duplicated_files_metaproduct():
    dag = DAG()
    PythonCallable(touch_root, File('a'), dag, name='task')
    PythonCallable(touch_root, {
        'product': File('a'),
        'another': File('b')
    },
                   dag,
                   name='another')

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    expected = ("Tasks must generate unique products. The following "
                "products appear in more than one task:\n* File('a') "
                "generated by tasks: 'another', and 'task'")

    assert expected == str(excinfo.value)


@pytest.mark.parametrize('class1, class2, return_value', [
    [SQLRelation, SQLRelation, [[], True]],
    [SQLiteRelation, SQLiteRelation, []],
    [GenericSQLRelation, GenericSQLRelation, []],
    [PostgresRelation, PostgresRelation, [[], True]],
    [PostgresRelation, SQLRelation, [[], True]],
],
                         ids=[
                             'sqlrelation',
                             'sqliterelation',
                             'genericsqlrelation',
                             'postgresrelation',
                             'mix',
                         ])
def test_duplicated_sql_product(class1, class2, return_value):
    dag = DAG()

    client = Mock()
    client.split_source = ';'
    client.connection.cursor().fetchone.return_value = return_value

    dag.clients[SQLScript] = client
    dag.clients[class1] = client
    dag.clients[class2] = client

    SQLScript('CREATE TABLE {{product}} AS SELECT * FROM table',
              class1(('schema', 'name', 'table')),
              dag=dag,
              name='task')
    SQLScript('CREATE TABLE {{product}} AS SELECT * FROM table',
              class2(('schema', 'name', 'table')),
              dag=dag,
              name='another')

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    assert 'Tasks must generate unique products.' in str(excinfo.value)


def test_path_for_plot_embed(tmp_directory):
    with util._path_for_plot(path_to_plot='embed', fmt='ext') as path:
        assert Path(path).exists()

    assert 'tmp' in path
    assert Path(path).suffix == '.ext'
    assert not Path(path).exists()


def test_path_for_plot(tmp_directory):
    with util._path_for_plot(path_to_plot='output.png', fmt='png') as path:
        Path(path).write_text('text')

    assert path == 'output.png'
    assert Path(path).read_text() == 'text'


def test_iter_file_products():
    dag = dag_simple()

    assert list(util.iter_file_products(dag)) == [
        dag['task'].product,
        dag['another'].product['product'],
        dag['another'].product['another'],
    ]


@pytest.mark.parametrize('fn, expected', [
    [dag_simple, ['output']],
    [dag_another, ['output',
                   str(Path('output', 'something')), 'products']],
])
def test_extract_product_prefixes(fn, expected):
    dag = fn()
    assert util.extract_product_prefixes(dag) == expected


def test_error_extract_product_prefixes_if_absolute_path():
    dag = DAG()

    path = str(
        Path('C:\\path\\to\\another' if platform.system() ==
             'Windows' else '/absolute/path/to/another'))

    PythonCallable(touch_root, File('output/first'), dag, name='task')
    PythonCallable(touch_root, {
        'product': File('output/product'),
        'another': File(path)
    },
                   dag,
                   name='another')

    with pytest.raises(ValueError) as excinfo:
        util.extract_product_prefixes(dag)

    expected = ("Absolute product paths are not " f"supported: {path!r}")

    assert str(excinfo.value) == expected
