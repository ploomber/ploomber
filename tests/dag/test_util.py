import platform
from unittest.mock import Mock
from pathlib import Path

import pytest

from ploomber import DAG
from ploomber.tasks import PythonCallable, SQLScript
from ploomber.products import (
    File,
    SQLRelation,
    SQLiteRelation,
    GenericSQLRelation,
    PostgresRelation,
)
from ploomber.exceptions import DAGWithDuplicatedProducts
from ploomber.dag import util


def dag_simple():
    dag = DAG()

    PythonCallable(touch_root, File("output/first"), dag, name="task")
    PythonCallable(
        touch_root,
        {"product": File("output/product"), "another": File("output/another")},
        dag,
        name="another",
    )

    return dag


def dag_another():
    dag = DAG()

    PythonCallable(touch_root, File("products/first"), dag, name="task")
    PythonCallable(
        touch_root,
        {
            "product": File("output/something/product"),
            "another": File("output/another"),
        },
        dag,
        name="another",
    )

    return dag


def touch_root(product):
    Path(str(product)).touch()


def touch(upstream, product):
    Path(str(product)).touch()


def test_duplicated_files():
    dag = DAG()
    PythonCallable(touch_root, File("a"), dag, name="task")
    PythonCallable(touch_root, File("a"), dag, name="another")

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    expected = (
        "Tasks must generate unique products. The following "
        "products appear in more than one task:\n* File('a') "
        "generated by tasks: 'another', and 'task'"
    )

    assert expected == str(excinfo.value)


def test_duplicated_files_one_absolute():
    dag = DAG()
    PythonCallable(touch_root, File("a"), dag, name="task")
    PythonCallable(touch_root, File(Path("a").resolve()), dag, name="another")

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    expected = (
        "Tasks must generate unique products. The following "
        "products appear in more than one task:\n* File('a') "
        "generated by tasks: 'another', and 'task'"
    )

    assert expected == str(excinfo.value)


def test_duplicated_files_metaproduct():
    dag = DAG()
    PythonCallable(touch_root, File("a"), dag, name="task")
    PythonCallable(
        touch_root, {"product": File("a"), "another": File("b")}, dag, name="another"
    )

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    expected = (
        "Tasks must generate unique products. The following "
        "products appear in more than one task:\n* File('a') "
        "generated by tasks: 'another', and 'task'"
    )

    assert expected == str(excinfo.value)


@pytest.mark.parametrize(
    "class1, class2, return_value",
    [
        [SQLRelation, SQLRelation, [[], True]],
        [SQLiteRelation, SQLiteRelation, []],
        [GenericSQLRelation, GenericSQLRelation, []],
        [PostgresRelation, PostgresRelation, [[], True]],
        [PostgresRelation, SQLRelation, [[], True]],
    ],
    ids=[
        "sqlrelation",
        "sqliterelation",
        "genericsqlrelation",
        "postgresrelation",
        "mix",
    ],
)
def test_duplicated_sql_product(class1, class2, return_value):
    dag = DAG()

    client = Mock()
    client.split_source = ";"
    client.connection.cursor().fetchone.return_value = return_value

    dag.clients[SQLScript] = client
    dag.clients[class1] = client
    dag.clients[class2] = client

    SQLScript(
        "CREATE TABLE {{product}} AS SELECT * FROM table",
        class1(("schema", "name", "table")),
        dag=dag,
        name="task",
    )
    SQLScript(
        "CREATE TABLE {{product}} AS SELECT * FROM table",
        class2(("schema", "name", "table")),
        dag=dag,
        name="another",
    )

    with pytest.raises(DAGWithDuplicatedProducts) as excinfo:
        dag.render()

    assert "Tasks must generate unique products." in str(excinfo.value)


def test_path_for_plot_embed(tmp_directory):
    with util._path_for_plot(path_to_plot="embed", fmt="ext") as path:
        assert Path(path).exists()

    assert "tmp" in path
    assert Path(path).suffix == ".ext"
    assert not Path(path).exists()


def test_path_for_plot(tmp_directory):
    with util._path_for_plot(path_to_plot="output.png", fmt="png") as path:
        Path(path).write_text("text")

    assert path == "output.png"
    assert Path(path).read_text() == "text"


def test_iter_file_products():
    dag = dag_simple()

    assert list(util.iter_file_products(dag)) == [
        dag["task"].product,
        dag["another"].product["product"],
        dag["another"].product["another"],
    ]


@pytest.mark.parametrize(
    "fn, expected",
    [
        [dag_simple, ["output"]],
        [dag_another, ["output", str(Path("output", "something")), "products"]],
    ],
)
def test_extract_product_prefixes(fn, expected):
    dag = fn()
    assert util.extract_product_prefixes(dag) == expected


def test_error_extract_product_prefixes_if_absolute_path():
    dag = DAG()

    path = str(
        Path(
            "C:\\path\\to\\another"
            if platform.system() == "Windows"
            else "/absolute/path/to/another"
        )
    )

    PythonCallable(touch_root, File("output/first"), dag, name="task")
    PythonCallable(
        touch_root,
        {"product": File("output/product"), "another": File(path)},
        dag,
        name="another",
    )

    with pytest.raises(ValueError) as excinfo:
        util.extract_product_prefixes(dag)

    expected = "Absolute product paths are not " f"supported: {path!r}"

    assert str(excinfo.value) == expected
