import sys
import os
from unittest.mock import Mock
import inspect
import pytest
from pathlib import Path
import importlib
import tempfile

import parso
from test_pkg import functions
import nbformat
import papermill as pm

from ploomber.sources.interact import (
    CallableInteractiveDeveloper,
    function_to_nb,
    body_elements_from_source,
    extract_imports,
    extract_imports_top,
    upstream_in_func_signature,
    add_upstream_to_func_signature,
)
from ploomber.sources import interact
from ploomber.spec.dagspec import DAGSpec
from ploomber.util import chdir_code


@pytest.fixture
def tmp_file():
    fd, tmp = tempfile.mkstemp()
    os.close(fd)
    yield tmp
    Path(tmp).unlink()


def replace_first_cell(nb, source, replacement):
    for cell in nb.cells:
        if cell["cell_type"] == "code":
            if cell["source"] == source:
                cell["source"] = replacement
                return

    raise Exception('Cell with source "{}" not found'.format(source))


def find_cell_tagged(nb, tag):
    for i, cell in enumerate(nb.cells):
        if tag in cell["metadata"].get("tags", {}):
            return cell, i

    raise Exception('Cell with tag "{}" not found'.format(tag))


def test_to_nb():
    dev = CallableInteractiveDeveloper(functions.large_function, params={})
    nb = dev.to_nb()

    # re-construct source generated by the notebook
    # this notebook has local imports anything below that should be the
    # function body
    _, index = find_cell_tagged(nb, "imports-local")
    source_from_nb = "\n".join(c["source"] for c in nb.cells[index + 1 :])

    # get original source code
    source_fn = inspect.getsource(functions.large_function)
    # remove indentation from the function body
    source_fn_lines = [line[4:] for line in source_fn.splitlines()]
    # ignore first line from function signature
    source_expected = "\n".join(source_fn_lines[1:])

    assert source_expected == source_from_nb


def test_hot_reload(backup_test_pkg):
    params = dict(a=1)
    dev = CallableInteractiveDeveloper(functions.some_function, params=params)

    # edit params
    params["a"] = 2

    # exporting should be aware of the change above
    nb = dev.to_nb()

    # edit notebook source
    nb.cells[-1]["source"] = "1 + 1"
    dev.overwrite(nb)

    nb_new = dev.to_nb()

    # check exported params match edited value
    cell, _ = find_cell_tagged(nb_new, "injected-parameters")
    assert "a = 2" in cell["source"]

    # should have the new content
    assert nb_new.cells[-1]["source"] == "1 + 1"


def test_unindent_function_with_mixed_identation(monkeypatch):
    source = """
def mixed_indentation():
    if True:
      pass

    if True:
          pass
"""

    body_elements, _ = body_elements_from_source(source)

    mock = Mock()
    mock.__name__ = "pkg.module"
    monkeypatch.setattr(interact.inspect, "getmodule", lambda _: mock)

    nb = function_to_nb(
        body_elements,
        imports_top="",
        imports_local="",
        imports_bottom="",
        params=dict(),
        fn=None,
        path=None,
    )

    first_cell = nb.cells[-3]["source"]
    second_cell = nb.cells[-2]["source"]
    third_cell = nb.cells[-1]["source"]

    assert first_cell == "if True:\n  pass"
    assert second_cell == ""
    assert third_cell == "if True:\n      pass"


@pytest.mark.xfail(
    reason="broken due to black formatting, we'll deprecate this API anyway"
)
@pytest.mark.parametrize(
    "fn,start",
    [
        (functions.simple, 0),
        (
            functions.this_is_a_function_with_a_very_long_name_with_forces_us_to_split_params,  # noqa
            1,
        ),
    ],
)
def test_find_signature_last_line(fn, start):
    assert interact.parse_function(fn)[1] == start


@pytest.mark.parametrize(
    "fn_name",
    [
        "simple",
        "simple_w_docstring",
        "simple_w_docstring_long",
        "multiple_lines_signature",
        "this_is_a_function_with_a_very_long_name_with_forces_us_to_split_params",
    ],
)
@pytest.mark.parametrize("switch_indent", [True, False])
def test_editing_function(fn_name, switch_indent, tmp_file, backup_test_pkg):
    if switch_indent:
        p = Path(functions.__file__)
        p.write_text(p.read_text().replace("    ", "\t"))
        functions_ = importlib.reload(functions)
    else:
        functions_ = functions

    with CallableInteractiveDeveloper(
        getattr(functions_, fn_name), {"upstream": None, "product": None}
    ) as tmp_nb:
        nb = nbformat.read(tmp_nb, as_version=nbformat.NO_CONVERT)
        replace_first_cell(nb, "x = 1", "x = 2")
        nbformat.write(nb, tmp_nb)

    reloaded = importlib.reload(functions)
    getattr(reloaded, fn_name)({"some_task": None}, None, tmp_file)
    assert Path(tmp_file).read_text() == "2"
    assert not Path(tmp_nb).exists()


# "large function" has whitespace, which should be preserved...
@pytest.mark.parametrize(
    "fn_name",
    [
        "simple",
        "simple_w_docstring",
        "simple_w_docstring_long",
        "multiple_lines_signature",
        "this_is_a_function_with_a_very_long_name_with_forces_us_to_split_params",
        "large_function",
    ],
)
@pytest.mark.parametrize("remove_trailing_newline", [False, True])
def test_unmodified_function(fn_name, remove_trailing_newline, backup_test_pkg):
    """
    This test makes sure the file is not modified if we don't change the
    notebook because whitespace is tricky
    """
    fn = getattr(functions, fn_name)
    path_to_file = Path(inspect.getfile(fn))

    content = path_to_file.read_text()
    # make sure the trailing newline in the file is not removed accidentally,
    # we need it as part of the test
    assert content[-1] == "\n", "expected a trailing newline character"

    if remove_trailing_newline:
        path_to_file.write_text(content[:-1])

    functions_reloaded = importlib.reload(functions)
    fn = getattr(functions_reloaded, fn_name)
    fn_source_original = inspect.getsource(fn)
    mod_source_original = path_to_file.read_text()

    with CallableInteractiveDeveloper(
        getattr(functions_reloaded, fn_name), {"upstream": None, "product": None}
    ) as tmp_nb:
        pass

    functions_edited = importlib.reload(functions)
    fn_source_new = inspect.getsource(getattr(functions_edited, fn_name))
    mod_source_new = path_to_file.read_text()

    assert fn_source_original == fn_source_new
    assert mod_source_original == mod_source_new
    assert not Path(tmp_nb).exists()


def test_move_function_down(backup_test_pkg):
    dev = CallableInteractiveDeveloper(functions.simple, params={})
    nb = dev.to_nb()
    nb.cells[-2]["source"] = "x = 2"

    # move source code down
    path = Path(backup_test_pkg, "functions.py")
    source = path.read_text()
    path.write_text("\n" + source)

    dev.overwrite(nb)

    importlib.reload(functions)

    source_fn = inspect.getsource(functions.simple)

    assert source_fn == (
        "def simple(upstream, product, path):\n    "
        'up = upstream["some_task"]\n    '
        "x = 2\n    Path(path).write_text(str(x))\n"
    )


def test_function_replace(backup_test_pkg):
    path = Path(backup_test_pkg, "functions.py")
    lines = path.read_text().splitlines()
    lines.insert(15, "def impostor():\n    pass\n")

    path.write_text("\n".join(lines))

    dev = CallableInteractiveDeveloper(functions.simple, params={})
    nb = dev.to_nb()

    # anything below this must be the function's body
    _, idx = find_cell_tagged(nb, "imports-local")
    fn_body = "\n".join([c.source for c in nb.cells[idx + 1 :]])

    assert fn_body == (
        'up = upstream["some_task"]\n' "x = 1\nPath(path).write_text(str(x))"
    )


def test_signature_line_break(backup_test_pkg):
    dev = CallableInteractiveDeveloper(functions.simple, params={})
    nb = dev.to_nb()

    nb.cells[-2]["source"] = "x = 2"

    path = Path(backup_test_pkg, "functions.py")
    source = path.read_text()
    lines = source.splitlines()
    lines[16] = "def simple(upstream, product,\npath):"
    path.write_text("\n".join(lines))

    dev.overwrite(nb)

    importlib.reload(functions)

    source_fn = inspect.getsource(functions.simple)
    print(source_fn)

    assert source_fn == (
        "def simple(upstream, product,\npath):\n    "
        'up = upstream["some_task"]\n'
        "    x = 2\n    Path(path).write_text(str(x))\n"
    )


def test_empty_cells_at_the_end(backup_test_pkg):
    dev = CallableInteractiveDeveloper(functions.simple, params={})
    nb = dev.to_nb()

    fmt = nbformat.versions[nbformat.current_nbformat]
    nb.cells.append(fmt.new_code_cell())

    path = Path(backup_test_pkg, "functions.py")
    source_old = path.read_text()

    dev.overwrite(nb)

    source_new = path.read_text()

    assert source_old == source_new


def test_added_imports(backup_test_pkg):
    params = {"upstream": None, "product": None}
    added_imports = "import os\nimport sys\n"

    with CallableInteractiveDeveloper(functions.simple, params) as tmp_nb:
        nb = nbformat.read(tmp_nb, as_version=nbformat.NO_CONVERT)
        cell, _ = find_cell_tagged(nb, "imports-top")
        cell.source += f"\n{added_imports}"
        nbformat.write(nb, tmp_nb)

    content = Path(inspect.getfile(functions.simple)).read_text()
    assert added_imports in content


def test_changes_cwd(backup_test_pkg):
    params = {"upstream": None, "product": None}
    source = None

    with CallableInteractiveDeveloper(functions.simple, params) as tmp_nb:
        nb = nbformat.read(tmp_nb, as_version=nbformat.NO_CONVERT)
        cell, _ = find_cell_tagged(nb, "debugging-settings")
        source = cell.source

    assert chdir_code(Path(".").resolve()) in source


def test_error_if_source_is_modified_while_editing(backup_test_pkg):
    path_to_file = Path(inspect.getfile(functions.simple))

    with pytest.raises(ValueError) as excinfo:
        with CallableInteractiveDeveloper(
            functions.simple, {"upstream": None, "product": None}
        ) as nb:
            path_to_file.write_text("")

    assert "Changes from the notebook were not saved back to the module" in str(
        excinfo.value
    )
    assert Path(nb).exists()


def test_get_func_and_class_names():
    source = """
def x():\n    pass
\n
class A:\n    pass
"""

    assert set(interact.get_func_and_class_names(parso.parse(source))) == {"x", "A"}


def test_make_import_from_definitions(monkeypatch):
    source = """
def x():\n    pass
\n
class A:\n    pass

def some_function():
    pass
"""
    mock_fn = Mock()
    mock_fn.__name__ = "some_function"

    mock_mod = Mock()
    mock_mod.__name__ = "some.module"

    monkeypatch.setattr(inspect, "getmodule", lambda _: mock_mod)

    assert (
        interact.make_import_from_definitions(parso.parse(source), mock_fn)
        == "from some.module import x, A"
    )


@pytest.mark.parametrize("task_name", ["raw", "clean"])
def test_develop_spec_with_local_functions(
    task_name, backup_spec_with_functions, no_sys_modules_cache
):
    """
    Check we can develop functions defined locally, the sample project includes
    relative imports, which should work when generating the temporary notebook
    """
    dag = DAGSpec("pipeline.yaml").to_dag()
    dag.render()

    fn = dag[task_name].source.primitive
    params = dag[task_name].params.to_json_serializable()

    if sys.platform == "win32":
        # edge case, wee need this to correctly parametrize the notebook
        # when running the test on windows
        params["product"] = str(params["product"]).replace("\\", "\\\\")

    with CallableInteractiveDeveloper(fn, params) as tmp_nb:
        pm.execute_notebook(tmp_nb, tmp_nb)


@pytest.mark.parametrize(
    "source, imports_top, imports_bottom, imports_local",
    [
        [
            """
import os
import sys

def test_extract_imports_function():
    pass
""",
            "\nimport os\nimport sys",
            None,
            None,
        ],
        [
            """
import os

def test_extract_imports_function():
    pass

def local():
    pass

import sys
""",
            "\nimport os",
            "\nimport sys",
            "from test_extract_imports_tmp import local",
        ],
    ],
)
def test_extract_imports(
    source,
    imports_top,
    imports_bottom,
    imports_local,
    tmp_directory_local,
    add_current_to_sys_path,
):
    Path("test_extract_imports_tmp.py").write_text(source)

    import test_extract_imports_tmp

    importlib.reload(test_extract_imports_tmp)

    imports_top_out, imports_local_out, imports_bottom_out = extract_imports(
        test_extract_imports_tmp.test_extract_imports_function
    )

    assert imports_top_out == imports_top
    assert imports_bottom_out == imports_bottom
    assert imports_local_out == imports_local


@pytest.mark.parametrize(
    "source, imports_top_expected, line_expected",
    [
        [
            """
from pathlib import Path

x = 1
    """,
            "\nfrom pathlib import Path",
            3,
        ],
        [
            """
from pathlib import Path
import os

x = 1
    """,
            "\nfrom pathlib import Path\nimport os",
            4,
        ],
        [
            """
import os

x = 1
    """,
            "\nimport os",
            3,
        ],
    ],
)
def test_extract_imports_top(source, imports_top_expected, line_expected):
    module = parso.parse(source)
    # print(module.children)
    imports_top, line = extract_imports_top(module, source.splitlines())

    assert imports_top == imports_top_expected
    assert line == line_expected


def test_add_upstream_modifies_signature(
    backup_spec_with_functions, no_sys_modules_cache
):
    dag = DAGSpec("pipeline.yaml").to_dag()
    dag.render()

    fn = dag["raw"].source.primitive
    params = dag["raw"].params.to_json_serializable()

    dev = CallableInteractiveDeveloper(fn, params)

    # add an upstream reference...
    nb = dev.to_nb()
    nb.cells[-1]["source"] += '\nupstream["some_task"]'
    dev.overwrite(nb)

    # source must be updated...
    source = Path("my_tasks", "raw", "functions.py").read_text()
    top_lines = "\n".join(source.splitlines()[:5])

    expected = (
        "from pathlib import Path\n\n\n"
        "def function(product, upstream):\n    Path(str(product)).touch()"
    )
    assert expected == top_lines

    # if we save again, nothing should change
    dev.overwrite(nb)

    source = Path("my_tasks", "raw", "functions.py").read_text()
    top_lines = "\n".join(source.splitlines()[:5])

    assert expected == top_lines


def test_remove_upstream_modifies_signature(backup_spec_with_functions):
    # by the time we reach this test, my_tasks.raw.functions has alread been
    # loaded (previous test), so we force reload to avoid wrongfully reading
    # the modified source code in the raw task
    from my_tasks.raw import functions

    importlib.reload(functions)

    dag = DAGSpec("pipeline.yaml").to_dag()
    dag.render()

    fn = dag["clean"].source.primitive
    params = dag["clean"].params.to_json_serializable()

    dev = CallableInteractiveDeveloper(fn, params)

    nb = dev.to_nb()
    # delete upstream reference
    del nb.cells[-2]
    dev.overwrite(nb)

    source = Path("my_tasks", "clean", "functions.py").read_text()
    top_lines = "\n".join(source.splitlines()[:5])

    expected = (
        "# adding this to make sure relative imports work "
        "fine\nfrom .util import util_touch\n\n\n"
        "def function(product):"
    )

    assert top_lines == expected


@pytest.mark.parametrize(
    "source, expected",
    [
        ["def x():\n    pass", False],
        ["def y(a, b):\n    pass", False],
        ["def z(a, b, upstream):\n    pass", True],
        ["def z(upstream, a, b):\n    pass", True],
    ],
)
def test_upstream_in_func_signature(source, expected):
    assert upstream_in_func_signature(source) == expected


@pytest.mark.parametrize(
    "source, expected",
    [
        ["def x():\n    z = 1", "def x(upstream):\n    z = 1"],
        ["def y(a, b):\n    pass", "def y(a, b, upstream):\n    pass"],
    ],
)
def test_add_upstream_to_func_signature(source, expected):
    assert add_upstream_to_func_signature(source) == expected
